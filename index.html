<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secret Lives of Quantum</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: #eee;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 2px solid #16213e;
        }
        
        .header h1 {
            font-size: 3em;
            margin: 0;
            color: #4fc3f7;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }
        
        .header p {
            font-size: 1.2em;
            margin: 20px 0;
            color: #bbb;
        }
        
        .main-section {
            margin: 60px 0;
            padding: 40px;
            background: rgba(22, 33, 62, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .chapter-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .chapter-number {
            color: #9c27b0;
            font-size: 1.2em;
            font-weight: normal;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .chapter-title {
            color: #4fc3f7;
            font-size: 2.2em;
            margin: 0;
            font-weight: bold;
        }
        
        
        .visualization-area {
            min-height: 400px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #16213e;
            border-radius: 10px;
            position: relative;
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .qubit {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .qubit.zero {
            background: radial-gradient(circle, #00bcd4, #0097a7);
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.5);
        }
        
        .qubit.one {
            background: radial-gradient(circle, #ff5722, #d84315);
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.5);
        }
        
        .qubit.superposition {
            background: radial-gradient(circle, #9c27b0, #7b1fa2);
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .btn {
            background: #4fc3f7;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: #29b6f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.primary {
            background: #4caf50;
        }
        
        .btn.primary:hover {
            background: #45a049;
        }
        
        .explanation {
            background: rgba(79, 195, 247, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4fc3f7;
        }
        
        .explanation h3 {
            color: #4fc3f7;
            margin-top: 0;
        }
        
        .entanglement-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #4fc3f7, #9c27b0, #4fc3f7);
            animation: flow 2s infinite;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .entanglement-line.active {
            opacity: 1;
        }
        
        @keyframes flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .quantum-gate {
            width: 80px;
            height: 40px;
            background: #4fc3f7;
            color: #1a1a2e;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            opacity: 0.5;
        }
        
        .quantum-gate.active {
            opacity: 1;
        }
        
        .quantum-gate:hover {
            background: #29b6f6;
            transform: scale(1.1);
        }
        
        .hidden {
            display: none !important;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #9c27b0);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        
        .slide-counter {
            color: #4fc3f7;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .progress-text {
            color: #999;
            font-size: 0.8em;
        }
        
        .bloch-sphere {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: 
                radial-gradient(ellipse 60px 40px at 60px 50px, rgba(255, 255, 255, 0.4), transparent 50%),
                radial-gradient(ellipse at 30% 20%, rgba(79, 195, 247, 0.6), rgba(79, 195, 247, 0.2) 40%, rgba(22, 33, 62, 0.8) 70%, rgba(10, 15, 30, 0.9));
            border: 2px solid rgba(79, 195, 247, 0.3);
            position: relative;
            margin: 20px auto;
            display: none;
            box-shadow: 
                inset -20px -20px 40px rgba(0, 0, 0, 0.3),
                inset 10px 10px 20px rgba(79, 195, 247, 0.2),
                0 10px 30px rgba(0, 0, 0, 0.4);
        }
        
        .bloch-sphere.active {
            display: block;
        }
        
        .bloch-axis {
            position: absolute;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.2));
            border-radius: 1px;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }
        
        .bloch-axis.vertical {
            width: 2px;
            height: 180px;
            left: 50%;
            top: 10px;
            transform: translateX(-50%);
            background: linear-gradient(0deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.2));
        }
        
        .bloch-axis.horizontal {
            width: 180px;
            height: 2px;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.2));
        }
        
        .bloch-axis::before {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
        }
        
        .bloch-axis.vertical::before {
            width: 6px;
            height: 6px;
            top: -3px;
            left: -2px;
        }
        
        .bloch-axis.horizontal::before {
            width: 6px;
            height: 6px;
            right: -3px;
            top: -2px;
        }
        
        .bloch-vector {
            position: absolute;
            width: 3px;
            height: 80px;
            background: #ff5722;
            border-radius: 2px;
            left: 50%;
            top: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) translateY(-100%) rotateZ(0deg);
            transition: all 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
            display: none;
        }
        
        .bloch-vector.active {
            display: block;
        }
        
        .bloch-vector.highlighted {
            width: 5px;
            height: 90px;
            background: #ff6b1a;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.8), 0 0 40px rgba(255, 87, 34, 0.4);
            animation: pulse-arrow 1s ease-in-out;
        }
        
        .bloch-vector::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -2px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid #ff5722;
            transition: all 0.5s ease;
        }
        
        .bloch-vector.highlighted::after {
            left: -3px;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid #ff6b1a;
            filter: drop-shadow(0 0 5px rgba(255, 87, 34, 0.8));
        }
        
        @keyframes pulse-arrow {
            0%, 100% { transform: translateX(-50%) translateY(-100%) rotateZ(0deg) scale(1); }
            50% { transform: translateX(-50%) translateY(-100%) rotateZ(0deg) scale(1.2); }
        }
        
        .bloch-labels {
            position: absolute;
            color: #4fc3f7;
            font-weight: bold;
            font-size: 1em;
            text-shadow: 0 0 5px rgba(79, 195, 247, 0.8), 0 1px 2px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        .bloch-labels.top {
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .bloch-labels.bottom {
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .classical-bit {
            width: 50px;
            height: 50px;
            border-radius: 5px;
            margin: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5em;
            color: #fff;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .classical-bit.zero {
            background: #333;
            border: 2px solid #666;
        }
        
        .classical-bit.one {
            background: #4fc3f7;
            border: 2px solid #29b6f6;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.5);
        }
        
        .classical-bit:hover {
            transform: scale(1.1);
        }
        
        .binary-display {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .binary-display.active {
            display: flex;
        }
        
        .bit-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .bit-box {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            color: #fff;
            transition: all 0.3s ease;
        }
        
        .bit-box.zero {
            background: #333;
            border: 2px solid #666;
        }
        
        .bit-box.one {
            background: #4fc3f7;
            border: 2px solid #29b6f6;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        .equals-sign {
            font-size: 1.5em;
            color: #4fc3f7;
            margin: 0 10px;
        }
        
        .result-display {
            font-size: 2em;
            color: #4fc3f7;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .binary-label {
            font-size: 0.8em;
            color: #999;
            margin-top: 5px;
        }
        
        .result-area {
            background: rgba(156, 39, 176, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #9c27b0;
            min-height: 50px;
            display: none;
        }
        
        .result-area.active {
            display: block;
        }
        
        .result-area h4 {
            color: #9c27b0;
            margin: 0 0 10px 0;
            font-size: 1em;
        }
        
        .result-area p {
            margin: 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>The Secret Lives of Quantum</h1>
            <p>Understanding quantum computing through interactive visualization</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-info">
                <div class="slide-counter" id="slide-counter">Step 1 of 16</div>
                <div class="progress-text" id="progress-text">Getting Started</div>
            </div>
        </div>
        
        <div class="main-section">
            <div class="chapter-header">
                <div class="chapter-number" id="chapter-number">Chapter 1</div>
                <h2 class="chapter-title" id="chapter-title">Classical Computing</h2>
            </div>
            
            <div class="visualization-area" id="visualization-area">
                <div class="classical-bit zero" id="classical-bit">0</div>
                <div class="binary-display" id="binary-display">
                    <div class="bit-row">
                        <div class="bit-box zero" id="bit-0">0</div>
                        <div class="bit-box one" id="bit-1">1</div>
                        <div class="bit-box zero" id="bit-2">0</div>
                        <div class="bit-box zero" id="bit-3">0</div>
                        <div class="bit-box zero" id="bit-4">0</div>
                        <div class="bit-box zero" id="bit-5">0</div>
                        <div class="bit-box zero" id="bit-6">0</div>
                        <div class="bit-box one" id="bit-7">1</div>
                        <span class="equals-sign">=</span>
                        <div class="result-display" id="result">A</div>
                    </div>
                    <div class="binary-label">ASCII Binary (01000001 = 65 = 'A')</div>
                </div>
                <div class="bloch-sphere" id="bloch-sphere">
                    <div class="bloch-axis vertical"></div>
                    <div class="bloch-axis horizontal"></div>
                    <div class="bloch-vector" id="bloch-vector"></div>
                    <div class="bloch-labels top">|0⟩</div>
                    <div class="bloch-labels bottom">|1⟩</div>
                </div>
                <div class="qubit zero" id="main-qubit">|0⟩</div>
                <div class="qubit zero hidden" id="second-qubit">|0⟩</div>
                <div class="entanglement-line" id="entanglement-line"></div>
                <div class="quantum-gate" id="gate-x">X</div>
                <div class="quantum-gate" id="gate-h">H</div>
                <div class="quantum-gate" id="gate-z">Z</div>
            </div>
            
            <div class="controls">
                <button class="btn" id="prev-btn" onclick="prevStep()">Previous Step</button>
                <button class="btn" id="manual-btn" onclick="performManualAction()">Try It</button>
                <button class="btn primary" id="next-btn" onclick="nextStep()">Next Step</button>
            </div>
            
            <div class="explanation" id="explanation">
                <h3>What is a Classical Bit?</h3>
                <p>All computers today use bits - the fundamental unit of information. A classical bit can only be in one of two states: 0 or 1. Click "Try It" to toggle between these two states.</p>
            </div>
            
            <div class="result-area" id="result-area">
                <h4>Try It Result</h4>
                <p id="result-text">Click "Try It" to see the result here!</p>
            </div>
        </div>
    </div>
    
    <script>
        let currentStep = 1;
        let isEntangled = false;
        let totalSteps = 16;
        
        const stepContent = {
            1: {
                chapter: "Chapter 1: Classical Computing",
                title: "What is a Classical Bit?",
                content: "All computers today use bits - the fundamental unit of information. A classical bit can only be in one of two states: 0 or 1. Click \"Try It\" to toggle between these two states.",
                action: () => {
                    resetVisualization();
                    showClassicalBit();
                    setClassicalBit('zero');
                    let currentBitState = 'zero';
                    setManualAction(() => {
                        currentBitState = currentBitState === 'zero' ? 'one' : 'zero';
                        setClassicalBit(currentBitState);
                        showResult(`The bit is now in state ${currentBitState === 'zero' ? '0' : '1'}. Classical bits can only be in one of these two definite states at any time.`, "Bit State");
                    });
                }
            },
            2: {
                chapter: "Chapter 1: Classical Computing",
                title: "Flipping to 1",
                content: "Classical bits can be flipped between 0 and 1 states. This is the foundation of all digital logic. Click \"Try It\" to flip this bit to 1.",
                action: () => {
                    setClassicalBit('zero');
                    setManualAction(() => {
                        setClassicalBit('one');
                        showResult("Great! You've flipped the bit to 1. Classical computers manipulate millions of these bits to perform calculations.", "Bit Flipped!");
                    });
                }
            },
            3: {
                chapter: "Chapter 1: Classical Computing",
                title: "Binary Information",
                content: "Multiple bits combine to represent human-readable information. Here's how 8 bits (1 byte) represent the letter 'A'. Click \"Try It\" to see different letters!",
                action: () => {
                    resetVisualization();
                    showBinaryDisplay();
                    setBinaryPatternSilent('A'); // Set up silently without showing result
                    setManualAction(() => {
                        const patterns = ['A', 'B', 'C', '?', '!'];
                        const currentIndex = patterns.indexOf(document.getElementById('result').textContent);
                        const nextIndex = (currentIndex + 1) % patterns.length;
                        setBinaryPattern(patterns[nextIndex]);
                    });
                }
            },
            4: {
                chapter: "Chapter 2: Introduction to Quantum",
                title: "Enter the Quantum World",
                content: "Quantum mechanics reveals that at the smallest scales, particles behave differently. A quantum bit (qubit) can exist in states that classical bits cannot. Let's explore this with the Bloch sphere.",
                action: () => {
                    resetVisualization();
                    showBlochSphere();
                    setManualAction(() => {
                        const sphere = document.getElementById('bloch-sphere');
                        sphere.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            sphere.style.transform = 'scale(1)';
                        }, 300);
                    });
                }
            },
            5: {
                chapter: "Chapter 2: The Bloch Sphere",
                title: "Qubit State |0⟩",
                content: "The Bloch sphere represents all possible qubit states. The north pole represents |0⟩ - equivalent to classical 0. The arrow shows the current qubit state.",
                action: () => {
                    setBlochVector('north');
                    setManualAction(() => {
                        const vector = document.getElementById('bloch-vector');
                        vector.classList.add('highlighted');
                        setTimeout(() => {
                            vector.classList.remove('highlighted');
                        }, 2000);
                        showResult("The qubit is in the |0⟩ state, pointing to the north pole. This is the quantum equivalent of classical bit 0.", "Qubit State |0⟩");
                    });
                }
            },
            6: {
                chapter: "Chapter 2: The Bloch Sphere",
                title: "Qubit State |1⟩",
                content: "The south pole represents |1⟩ - equivalent to classical 1. Click \"Try It\" to flip the qubit to |1⟩ and see the arrow move!",
                action: () => {
                    setBlochVector('north');
                    setManualAction(() => {
                        setBlochVector('south');
                        showResult("The qubit is now in the |1⟩ state, pointing to the south pole. Notice how the arrow flipped to the opposite pole!", "Qubit State |1⟩");
                    });
                }
            },
            7: {
                chapter: "Chapter 2: The Bloch Sphere",
                title: "Superposition States",
                content: "🌟 Here's where quantum gets weird! The equator represents superposition - the qubit exists in both |0⟩ and |1⟩ states simultaneously. Click \"Try It\" to see!",
                action: () => {
                    setBlochVector('south');
                    setManualAction(() => {
                        setBlochVector('equator');
                        showResult("🌟 The qubit is now in superposition! The arrow points to the equator, representing a state that's both |0⟩ and |1⟩ simultaneously.", "Superposition State");
                    });
                }
            },
            8: {
                chapter: "Chapter 3: Quantum Qubits",
                title: "From Bloch Sphere to Qubits",
                content: "Now let's see how the Bloch sphere translates to actual qubits. Each qubit state corresponds to a position on the sphere. Let's start with |0⟩.",
                action: () => {
                    hideBlochSphere();
                    showMainQubit();
                    setMainQubit('zero');
                    setManualAction(() => {
                        setMainQubit('zero');
                        showResult("This qubit is in the |0⟩ state - corresponding to the north pole of the Bloch sphere.", "Qubit |0⟩ State");
                    });
                }
            },
            9: {
                chapter: "Chapter 4: Quantum Gates",
                title: "The X Gate (NOT Gate)",
                content: "Quantum gates manipulate qubit states. The X gate flips a qubit: |0⟩ → |1⟩ and |1⟩ → |0⟩. Click \"Try It\" to apply an X gate!",
                action: () => {
                    resetToSingleQubit();
                    setMainQubit('zero');
                    showGate('X');
                    setManualAction(() => applyGate('X'));
                }
            },
            10: {
                chapter: "Chapter 4: Quantum Gates",
                title: "The H Gate (Hadamard)",
                content: "The H gate creates superposition! It transforms |0⟩ → |+⟩ (superposition). Click \"Try It\" to apply a Hadamard gate!",
                action: () => {
                    setMainQubit('zero');
                    showGate('H');
                    setManualAction(() => applyGate('H'));
                }
            },
            11: {
                chapter: "Chapter 4: Quantum Gates",
                title: "The Z Gate (Phase Flip)",
                content: "The Z gate applies a phase flip. While it doesn't change |0⟩ or |1⟩ visually, it affects the quantum phase. Click \"Try It\" to see the visual effect!",
                action: () => {
                    setMainQubit('one');
                    showGate('Z');
                    setManualAction(() => applyGate('Z'));
                }
            },
            12: {
                chapter: "Chapter 4: Quantum Gates",
                title: "The Z Gate (Phase Flip)",
                content: "The Z gate applies a phase flip. While it doesn't change |0⟩ or |1⟩ visually, it affects the quantum phase. Click \"Try It\" to see the visual effect!",
                action: () => {
                    resetToSingleQubit();
                    setMainQubit('one');
                    showGate('Z');
                    setManualAction(() => applyGate('Z'));
                }
            },
            13: {
                chapter: "Chapter 5: Quantum Measurement",
                title: "Measurement Collapses Superposition",
                content: "When you measure a qubit in superposition, it randomly collapses to either |0⟩ or |1⟩. Click \"Try It\" to measure the qubit and see this random collapse!",
                action: () => {
                    resetToSingleQubit();
                    setMainQubit('superposition');
                    setManualAction(() => measureQubit());
                }
            },
            14: {
                chapter: "Chapter 5: Quantum Measurement",
                title: "Measurement is Random",
                content: "Each measurement gives a random result! Click \"Try It\" multiple times to see how the same superposition qubit can collapse to different states.",
                action: () => {
                    setMainQubit('superposition');
                    setManualAction(() => measureQubit());
                }
            },
            15: {
                chapter: "Chapter 6: Quantum Entanglement",
                title: "Entangled Qubits",
                content: "When two qubits are entangled, measuring one instantly affects the other, regardless of distance. Click \"Try It\" to see entangled measurement!",
                action: () => {
                    resetVisualization();
                    showTwoQubits();
                    createEntanglement();
                    setManualAction(() => measureEntangledPair());
                }
            },
            16: {
                chapter: "Journey Complete!",
                title: "🎉 Congratulations!",
                content: "You've learned the fundamentals of quantum computing: qubits, superposition, measurement, entanglement, and quantum gates. These concepts form the foundation of quantum algorithms and quantum computing's incredible potential!",
                action: () => {
                    resetToSingleQubit();
                    setMainQubit('superposition');
                    document.getElementById('next-btn').textContent = 'Start Over';
                    document.getElementById('manual-btn').style.display = 'none';
                }
            }
        };
        
        let manualAction = null;
        
        function setManualAction(action) {
            manualAction = action;
        }
        
        function performManualAction() {
            if (manualAction) {
                manualAction();
            }
        }
        
        function nextStep() {
            if (currentStep >= totalSteps) {
                // Restart
                currentStep = 1;
                document.getElementById('next-btn').textContent = 'Next Step';
                document.getElementById('manual-btn').style.display = 'inline-block';
            } else {
                currentStep++;
            }
            
            hideResult(); // Reset Try It state
            updateProgress();
            updateButtonStates();
            
            const step = stepContent[currentStep];
            if (step) {
                updateChapterTitle(step.chapter);
                updateExplanation(step.content, step.title);
                step.action();
            }
        }
        
        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                
                hideResult(); // Reset Try It state
                updateProgress();
                updateButtonStates();
                
                const step = stepContent[currentStep];
                if (step) {
                    updateChapterTitle(step.chapter);
                    updateExplanation(step.content, step.title);
                    step.action();
                }
            }
        }
        
        
        function updateProgress() {
            const progressFill = document.getElementById('progress-fill');
            const slideCounter = document.getElementById('slide-counter');
            const progressText = document.getElementById('progress-text');
            
            const percentage = (currentStep / totalSteps) * 100;
            progressFill.style.width = percentage + '%';
            
            slideCounter.textContent = `Step ${currentStep} of ${totalSteps}`;
            
            // Update progress text based on step
            const progressMessages = {
                1: "Getting Started",
                2: "Classical Basics", 
                3: "Binary Information",
                4: "Entering Quantum",
                5: "Bloch Sphere Basics",
                6: "Quantum States",
                7: "Superposition",
                8: "Quantum Qubits",
                9: "Quantum Gates",
                10: "Gate Operations",
                11: "Advanced Gates",
                12: "Measurement",
                13: "Entanglement",
                14: "Quantum Correlations",
                15: "Advanced Concepts",
                16: "Journey Complete!"
            };
            
            progressText.textContent = progressMessages[currentStep] || "Learning";
        }
        
        function updateButtonStates() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const manualBtn = document.getElementById('manual-btn');
            
            // Update previous button state
            if (currentStep <= 1) {
                prevBtn.disabled = true;
                prevBtn.style.opacity = '0.5';
            } else {
                prevBtn.disabled = false;
                prevBtn.style.opacity = '1';
            }
            
            // Update next button text for final step
            if (currentStep >= totalSteps) {
                nextBtn.textContent = 'Start Over';
                manualBtn.style.display = 'none';
            } else {
                nextBtn.textContent = 'Next Step';
                manualBtn.style.display = 'inline-block';
            }
        }
        
        function updateChapterTitle(chapterText) {
            // Parse "Chapter 1: Classical Computing" format
            const parts = chapterText.split(': ');
            const chapterNumber = parts[0]; // "Chapter 1"
            const chapterTitle = parts[1]; // "Classical Computing"
            
            document.getElementById('chapter-number').textContent = chapterNumber;
            document.getElementById('chapter-title').textContent = chapterTitle;
        }
        
        function updateExplanation(content, title) {
            const explanation = document.getElementById('explanation');
            explanation.innerHTML = `<h3>${title}</h3><p>${content}</p>`;
        }
        
        function showResult(content, title = "Try It Result") {
            const resultArea = document.getElementById('result-area');
            const resultText = document.getElementById('result-text');
            resultArea.classList.add('active');
            resultArea.querySelector('h4').textContent = title;
            resultText.textContent = content;
        }
        
        function hideResult() {
            const resultArea = document.getElementById('result-area');
            resultArea.classList.remove('active');
        }
        
        function resetVisualization() {
            document.getElementById('classical-bit').style.display = 'none';
            document.getElementById('binary-display').classList.remove('active');
            document.getElementById('bloch-sphere').classList.remove('active');
            document.getElementById('bloch-vector').classList.remove('active', 'highlighted');
            document.getElementById('main-qubit').style.display = 'none';
            document.getElementById('second-qubit').classList.add('hidden');
            document.getElementById('entanglement-line').classList.remove('active');
            document.querySelectorAll('.quantum-gate').forEach(gate => {
                gate.classList.remove('active');
                gate.style.display = 'none';
            });
            hideResult();
            isEntangled = false;
        }
        
        function showClassicalBit() {
            document.getElementById('classical-bit').style.display = 'flex';
            document.getElementById('bloch-sphere').classList.remove('active');
            document.getElementById('main-qubit').style.display = 'none';
        }
        
        function hideClassicalBit() {
            document.getElementById('classical-bit').style.display = 'none';
        }
        
        function showBlochSphere() {
            document.getElementById('bloch-sphere').classList.add('active');
            document.getElementById('main-qubit').style.display = 'none';
        }
        
        function hideBlochSphere() {
            document.getElementById('bloch-sphere').classList.remove('active');
        }
        
        function showMainQubit() {
            document.getElementById('main-qubit').style.display = 'flex';
            document.getElementById('bloch-sphere').classList.remove('active');
        }
        
        function setClassicalBit(state) {
            const bit = document.getElementById('classical-bit');
            bit.className = `classical-bit ${state}`;
            bit.textContent = state === 'zero' ? '0' : '1';
        }
        
        function setBlochVector(position) {
            const vector = document.getElementById('bloch-vector');
            vector.classList.add('active'); // Show the vector
            
            if (position === 'north') {
                vector.style.transform = 'translateX(-50%) translateY(-100%) rotateZ(0deg)';
            } else if (position === 'south') {
                vector.style.transform = 'translateX(-50%) translateY(-100%) rotateZ(180deg)';
            } else if (position === 'equator') {
                vector.style.transform = 'translateX(-50%) translateY(-100%) rotateZ(90deg)';
            }
        }
        
        function showBinaryDisplay() {
            document.getElementById('binary-display').classList.add('active');
            document.getElementById('classical-bit').style.display = 'none';
        }
        
        function setBinaryPatternSilent(char) {
            const patterns = {
                'A': '01000001',
                'B': '01000010',
                'C': '01000011',
                '?': '00111111',
                '!': '00100001'
            };
            
            const pattern = patterns[char] || '00000000';
            const result = document.getElementById('result');
            const label = document.getElementById('binary-display').querySelector('.binary-label');
            
            // Update each bit without animation
            for (let i = 0; i < 8; i++) {
                const bit = document.getElementById(`bit-${i}`);
                const value = pattern[i];
                bit.textContent = value;
                bit.className = `bit-box ${value === '0' ? 'zero' : 'one'}`;
            }
            
            result.textContent = char;
            const decimal = parseInt(pattern, 2);
            label.textContent = `ASCII Binary (${pattern} = ${decimal} = '${char}')`;
        }
        
        function setBinaryPattern(char) {
            setBinaryPatternSilent(char);
            
            const patterns = {
                'A': '01000001',
                'B': '01000010',
                'C': '01000011',
                '?': '00111111',
                '!': '00100001'
            };
            
            const pattern = patterns[char] || '00000000';
            const decimal = parseInt(pattern, 2);
            
            // Animate the change
            for (let i = 0; i < 8; i++) {
                const bit = document.getElementById(`bit-${i}`);
                bit.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    bit.style.transform = 'scale(1)';
                }, 100 + i * 50);
            }
            
            showResult(`The 8 bits now represent '${char}'. In ASCII encoding, ${pattern} equals ${decimal} which displays as '${char}'. Try clicking again!`, "Binary Result");
        }
        
        function setMainQubit(state) {
            const qubit = document.getElementById('main-qubit');
            qubit.className = `qubit ${state}`;
            qubit.textContent = state === 'zero' ? '|0⟩' : state === 'one' ? '|1⟩' : '|+⟩';
        }
        
        function setSecondQubit(state) {
            const qubit = document.getElementById('second-qubit');
            qubit.className = `qubit ${state}`;
            qubit.textContent = state === 'zero' ? '|0⟩' : state === 'one' ? '|1⟩' : '|+⟩';
        }
        
        function showTwoQubits() {
            document.getElementById('second-qubit').classList.remove('hidden');
            setMainQubit('zero');
            setSecondQubit('zero');
        }
        
        function resetToSingleQubit() {
            document.getElementById('second-qubit').classList.add('hidden');
            document.getElementById('entanglement-line').classList.remove('active');
            document.querySelectorAll('.quantum-gate').forEach(gate => {
                gate.classList.remove('active');
                gate.style.display = 'none';
            });
            isEntangled = false;
        }
        
        function createEntanglement() {
            setMainQubit('superposition');
            setSecondQubit('superposition');
            document.getElementById('entanglement-line').classList.add('active');
            isEntangled = true;
        }
        
        function measureQubit() {
            const result = Math.random() < 0.5 ? 'zero' : 'one';
            setMainQubit(result);
            
            setTimeout(() => {
                const resultText = result === 'zero' ? '|0⟩' : '|1⟩';
                showResult(`Measurement result: ${resultText}. Try clicking "Try It" again to see another random result!`, "Measurement Result");
            }, 500);
        }
        
        function measureEntangledPair() {
            if (!isEntangled) return;
            
            const result1 = Math.random() < 0.5 ? 'zero' : 'one';
            const result2 = result1 === 'zero' ? 'one' : 'zero'; // Always opposite for this demo
            
            setMainQubit(result1);
            setSecondQubit(result2);
            
            setTimeout(() => {
                const result1Text = result1 === 'zero' ? '|0⟩' : '|1⟩';
                const result2Text = result2 === 'zero' ? '|0⟩' : '|1⟩';
                showResult(`Entangled measurement: Left qubit is ${result1Text}, Right qubit is ${result2Text}. Notice they're always opposite!`, "Entangled Measurement");
            }, 500);
        }
        
        function showGate(gateName) {
            document.querySelectorAll('.quantum-gate').forEach(gate => {
                gate.style.display = 'none';
                gate.classList.remove('active');
            });
            
            const gate = document.getElementById(`gate-${gateName.toLowerCase()}`);
            gate.style.display = 'flex';
            gate.classList.add('active');
        }
        
        function applyGate(gateName) {
            const qubit = document.getElementById('main-qubit');
            
            if (gateName === 'X') {
                if (qubit.classList.contains('zero')) {
                    setMainQubit('one');
                } else if (qubit.classList.contains('one')) {
                    setMainQubit('zero');
                }
            } else if (gateName === 'H') {
                setMainQubit('superposition');
            } else if (gateName === 'Z') {
                // Visual phase flip effect
                qubit.style.transform = 'rotateY(180deg)';
                setTimeout(() => {
                    qubit.style.transform = 'rotateY(0deg)';
                }, 500);
            }
        }
        
        // Initialize
        window.addEventListener('load', () => {
            updateProgress();
            updateButtonStates();
            stepContent[1].action();
            
            // Position entanglement line
            const mainQubit = document.getElementById('main-qubit');
            const secondQubit = document.getElementById('second-qubit');
            const line = document.getElementById('entanglement-line');
            
            const observer = new ResizeObserver(() => {
                const container = document.getElementById('visualization-area');
                const rect1 = mainQubit.getBoundingClientRect();
                const rect2 = secondQubit.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                const startX = rect1.left + rect1.width/2 - containerRect.left;
                const endX = rect2.left + rect2.width/2 - containerRect.left;
                const centerY = rect1.top + rect1.height/2 - containerRect.top;
                
                line.style.left = startX + 'px';
                line.style.top = centerY + 'px';
                line.style.width = Math.abs(endX - startX) + 'px';
            });
            
            observer.observe(document.getElementById('visualization-area'));
        });
    </script>
</body>
</html>